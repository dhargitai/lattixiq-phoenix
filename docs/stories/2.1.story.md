# Story 2.1: Sprint View Implementation

## Status
Draft

## Story
**As a** startup founder,
**I want** to initiate and complete a Phoenix Framework decision sprint,
**so that** I can break through my decision paralysis with guided support

## Acceptance Criteria
1. User can initiate a new decision sprint with problem input
2. System conducts interactive diagnostic interview
3. Type 1/Type 2 decision classification works correctly
4. Validated Problem Brief is generated and confirmed
5. Semantic framework selection returns relevant models
6. Framework application guides user step-by-step
7. Commitment Memo is generated with all required sections
8. Micro-Bet and First Domino are clearly defined

## Tasks / Subtasks
- [ ] Task 1: Create Sprint View page structure (AC: 1, 2)
  - [ ] Create `apps/web/app/sprint/page.tsx` using Next.js App Router
  - [ ] Set up page layout with DaisyUI components
  - [ ] Implement basic routing and navigation
- [ ] Task 2: Implement sprint state management (AC: 1, 2, 3, 4)
  - [ ] Create Zustand store for sprint session state
  - [ ] Define state interfaces for problem intake and sprint progress
  - [ ] Implement state persistence during sprint session
- [ ] Task 3: Create problem intake components (AC: 1, 2)
  - [ ] Build problem input form with validation
  - [ ] Create interactive diagnostic interview UI
  - [ ] Implement conversational UI patterns using AI Elements
- [ ] Task 4: Integrate Vercel AI SDK for streaming (AC: 2, 3, 4, 5, 6, 7, 8)
  - [ ] Configure streaming endpoint integration with POST /api/sprint
  - [ ] Implement useChat hook for real-time conversations
  - [ ] Add streaming response UI components
- [ ] Task 5: Implement decision classification logic (AC: 3)
  - [ ] Create Type 1/Type 2 decision classification UI
  - [ ] Integrate with core engine decision logic
  - [ ] Display classification results to user
- [ ] Task 6: Build Problem Brief generation (AC: 4)
  - [ ] Create Problem Brief display component
  - [ ] Implement user confirmation flow
  - [ ] Add editing capabilities for brief refinement
- [ ] Task 7: Implement semantic framework selection (AC: 5, 6)
  - [ ] Integrate with semantic search API endpoint
  - [ ] Display framework recommendations
  - [ ] Create framework selection and application UI
- [ ] Task 8: Create Commitment Memo generation (AC: 7, 8)
  - [ ] Build Commitment Memo display component
  - [ ] Implement Micro-Bet and First Domino sections
  - [ ] Add export/save functionality
- [ ] Task 9: Add sprint progress tracking (AC: 1-8)
  - [ ] Create progress indicator component
  - [ ] Implement sprint stage navigation
  - [ ] Add save/resume sprint functionality
- [ ] Task 10: Unit testing implementation
  - [ ] Write component tests using Vitest
  - [ ] Test Zustand store functionality
  - [ ] Test AI SDK integration points
- [ ] Task 11: Mobile responsiveness verification (AC: 1-8)
  - [ ] Test sprint flow on mobile viewport
  - [ ] Verify DaisyUI responsive components
  - [ ] Ensure touch-friendly interactions

## Dev Notes

### Previous Story Insights
From Story 1.1: Turborepo monorepo structure is established with packages/core for type definitions and apps/web for Next.js app. Type sharing is working correctly between packages.

### Data Models
From architecture documents [Source: architecture/data-models.md]:
- **User interface**: UUID, email, timestamps, user preference fields for authentication and tracking
- **DecisionSprint interface**: For storing problem briefs and commitment memos as JSONB
- **KnowledgeContent interface**: Mental models with 1536-dimensional vector embeddings for semantic search

### API Specifications
From architecture [Source: architecture/api-specification.md]:
- **Streaming Endpoint**: `POST /api/sprint` - Handles entire interactive Phoenix Framework session with streaming UI response managed by Vercel AI SDK
- **Request Body**: Object containing current conversation state and user inputs
- **Response**: Streaming UI response for real-time conversation

### Component Specifications
From architecture [Source: architecture/components.md]:
- **Web UI (Next.js Application)**: User-facing presentation layer managing conversational UI, rendering components, and handling client-side state
- **Phoenix Core Engine**: UI-agnostic TypeScript package with business logic - must be imported for decision sprint logic
- **API Layer**: Netlify Functions serving as bridge between Web UI, Core Engine, and Supabase

### File Locations
Based on unified project structure [Source: architecture/unified-project-structure.md]:
- **Main Sprint Page**: `apps/web/app/sprint/page.tsx` (Next.js App Router)
- **Sprint Components**: `apps/web/components/sprint/` directory for UI components
- **State Management**: `apps/web/lib/stores/` for Zustand stores
- **Type Imports**: Import from `@phoenix/core` package for shared types
- **UI Components**: Use DaisyUI components from shared packages/ui

### Testing Requirements
From architecture [Source: architecture/tech-stack.md]:
- **Unit/Integration Testing**: Vitest v3.4.2 as test runner
- **E2E Testing**: Playwright v1.55 for end-to-end testing
- **Test Location**: Follow Next.js testing conventions alongside component files

### Technical Constraints
From tech stack and coding standards [Source: architecture/tech-stack.md, architecture/coding-standards.md]:
- **Framework**: Next.js v15.5 with App Router required
- **AI Integration**: Vercel AI SDK v5.0.15 + AI Elements v1.0.5 for streaming conversations
- **State Management**: Zustand v5.0.7 for global state management (avoid prop drilling)
- **UI Library**: DaisyUI v5.0.50 + Tailwind CSS v4.1.12 for styling
- **Type Safety**: Import all shared types from packages/core, no React/DOM code in core package
- **Performance**: Response latency < 500ms, Time to Interactive < 3 seconds
- **Mobile**: Mobile-first responsive design required

### Architecture Integration Points
- **Core Engine Integration**: Import business logic from packages/core for decision sprint processing
- **Database Integration**: Use Supabase client for user authentication and sprint persistence
- **Semantic Search**: Integration with knowledge management system for framework selection
- **Streaming AI**: Real-time conversational interface with Google Gemini via Vercel AI SDK

## Testing

### Testing Standards
From architecture [Source: architecture/tech-stack.md]:
- **Test Runner**: Vitest v3.4.2 for unit and integration tests
- **E2E Framework**: Playwright v1.55 for end-to-end testing
- **Test Files**: Co-locate test files with components using `.test.tsx` naming convention
- **Coverage**: Aim for comprehensive coverage of sprint flow logic and state management
- **Integration Tests**: Test API endpoint integration and streaming functionality

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*Results from QA Agent review will be populated here*