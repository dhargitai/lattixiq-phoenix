# Story 2.0: Phoenix Core Session Management & Orchestration

This is based on docs/architecture/phoenix-core-engine.md

## Status
Approved

## Story
**As a** Phoenix Framework system,
**I want** a comprehensive session management and AI orchestration engine,
**so that** I can manage conversational decision sprints, track phases, route messages to appropriate handlers, and coordinate multiple AI models effectively with full conversation branching support

## Acceptance Criteria
1. Session Management: Create, load, update, and manage decision sprint sessions with full state persistence
2. Message History: Store and retrieve conversation messages with full branching support for exploration and rollback
3. Phase Orchestration: Track and manage progression through Phoenix Framework phases with validation
4. AI Model Routing: Dynamically select AI models based on task type (GPT-4.1 for analysis, Gemini Flash for quick responses, Gemini Pro for deep thinking)
5. Problem Embedding: Generate embeddings for user problems to enable semantic framework matching
6. Framework Selection: Find, score, and curate relevant mental models/frameworks based on user's problem
7. Context Assembly: Prepare proper prompts with previous messages, artifacts, and selected frameworks
8. Artifact Management: Store and version session artifacts (problem briefs, commitment memos, diagnostic notes)
9. Performance Tracking: Monitor timing, token usage, and costs across all operations
10. Conversation Branching: Support "jump back" functionality to try different conversation paths
11. Streaming Integration: Work seamlessly with Vercel AI SDK for real-time streaming responses
12. Error Handling: Comprehensive error recovery and user-friendly error messages

## Tasks / Subtasks

### Core Infrastructure Setup
- [x] Task 1: Create comprehensive database schema and migration (AC: 1, 2, 3, 8, 10)
  - [x] Design sessions, messages, artifacts, phase_transitions tables with proper indexes
  - [x] Add message_embeddings table with vector support
  - [x] Create framework_selections table for tracking chosen frameworks
  - [x] Implement proper RLS policies for user data security
  - [x] Add triggers for automatic timestamp updates and session activity tracking

### Type System & Interfaces
- [x] Task 2: Define comprehensive TypeScript interfaces in packages/core (AC: 1-12)
  - [x] Session, Message, SessionArtifact, PhaseTransition interfaces
  - [x] PhaseHandler, FrameworkSelection, ValidationResult interfaces  
  - [x] Service interfaces: ISessionManager, IFrameworkSelector, IAIRouter
  - [x] AI model types, phase enums, artifact content types
  - [x] Error types and performance metrics interfaces

### Session Management Service
- [x] Task 3: Implement SessionManager with conversation branching (AC: 1, 2, 10)
  - [x] Create sessions with configurable model preferences and features
  - [x] Load/update sessions with proper caching for performance
  - [x] Add/retrieve messages with parent-child relationships for branching
  - [x] Implement branchFromMessage() to create new conversation branches
  - [x] Save/retrieve versioned artifacts with conflict resolution
  - [x] Manage session state persistence and recovery

### Framework Selection Engine
- [ ] Task 4: Create FrameworkSelector service adapted from action-roadmap demo (AC: 5, 6)
  - [ ] Generate OpenAI embeddings for user problem statements
  - [ ] Implement semantic search against knowledge_content using pgvector
  - [ ] Score frameworks using relevance, applicability, and foundational value
  - [ ] Curate final framework selection with diversity and complementarity
  - [ ] Store framework selections with detailed score breakdowns
  - [ ] Support filtering by persona, startup phase, and problem categories

### AI Model Orchestration
- [ ] Task 5: Build AIRouter service with multi-model strategy (AC: 4, 7, 11)
  - [ ] Implement model selection logic: GPT-4.1 (analysis), Gemini Flash (quick), Gemini Pro (deep)
  - [ ] Support per-message model override for testing and optimization
  - [ ] Assemble context with messages, artifacts, and frameworks for prompts
  - [ ] Integrate with Vercel AI SDK for streaming responses
  - [ ] Track performance metrics (tokens, timing, costs) per model
  - [ ] Handle model-specific timeouts and retry logic

### Phase Management System
- [x] Task 6: Implement PhaseManager state machine (AC: 3)
  - [x] Define phase definitions with validation rules and requirements
  - [x] Track phase readiness with scoring and missing element detection
  - [x] Validate phase transitions with comprehensive validation results
  - [x] Log phase transitions with reasoning and triggering messages
  - [x] Support phase rollback for conversation branching scenarios
  - [x] Implement phase-specific model preferences and timeouts

### Phoenix Orchestrator (Main Controller)
- [ ] Task 7: Build PhoenixOrchestrator coordination engine adapted from demo (AC: 1-12)
  - [ ] Coordinate all services in proper sequence with error handling
  - [ ] Process incoming messages through appropriate phase handlers
  - [ ] Manage phase transitions based on validation results
  - [ ] Handle framework selection during appropriate phases
  - [ ] Track comprehensive performance metrics across all operations
  - [ ] Implement timeout management and graceful degradation
  - [ ] Support conversation branching and state management

### Phase Handler Classes
- [x] Task 8: Implement individual phase handlers (AC: 3, 8)
  - [x] ProblemIntakeHandler: Guide problem statement collection
  - [x] DiagnosticInterviewHandler: Conduct structured problem exploration
  - [x] TypeClassificationHandler: Classify Type 1 vs Type 2 decisions
  - [x] FrameworkSelectionHandler: Present and apply selected frameworks (mock)
  - [x] FrameworkApplicationHandler: Guide framework application process
  - [x] CommitmentMemoHandler: Generate final commitment memo
  - [x] Each handler implements PhaseHandler interface with validation

### API Integration
- [ ] Task 9: Create streaming API endpoint (AC: 11, 12)
  - [ ] POST /api/sprint route using Next.js App Router
  - [ ] Accept message, session_id, and optional model override parameters
  - [ ] Route through PhoenixOrchestrator for processing
  - [ ] Stream responses using Vercel AI SDK
  - [ ] Handle conversation branching endpoints
  - [ ] Return proper error responses with user-friendly messages
  - [ ] Support session management operations (create, load, branch)

### Error Handling & Performance
- [x] Task 10: Implement comprehensive error handling and monitoring (AC: 9, 12)
  - [x] Custom error types with contextual information and recovery suggestions
  - [x] Performance tracker class from demo with Phoenix-specific metrics
  - [x] Timeout management for all async operations
  - [x] Retry logic with exponential backoff for AI model calls
  - [x] Logging integration with Winston for debugging and monitoring
  - [x] Graceful degradation when services are unavailable

### Testing Infrastructure  
- [ ] Task 11: Create comprehensive test suite (AC: 1-12)
  - [ ] Unit tests for all service classes using Vitest
  - [ ] Integration tests for database operations and AI model integration
  - [ ] Mock implementations for external services (OpenAI, Gemini)
  - [ ] Test conversation branching scenarios and edge cases
  - [ ] Performance benchmarks for framework selection and phase transitions
  - [ ] E2E tests for complete decision sprint flows using Playwright

## Dev Notes

### Previous Story Insights
From Story 1.1: Monorepo structure established with packages/core for business logic and proper TypeScript type sharing. Cross-package imports are working correctly.

### Data Models & Database Schema
From architecture documents [Source: architecture/data-models.md]:
- **Sessions Table**: ID, user_id, status, current_phase, phase_states (JSONB), config (JSONB), timestamps
- **Messages Table**: ID, session_id, parent_message_id (branching), role, content, model_used, phase_number, is_active_branch
- **Message Embeddings**: message_id, embedding vector(1536), embedding_model 
- **Session Artifacts**: ID, session_id, artifact_type, content (JSONB), phase_created, version, is_current
- **Phase Transitions**: ID, session_id, from_phase, to_phase, validation_results (JSONB), transition_reason
- **Framework Selections**: ID, session_id, knowledge_content_id, relevance_score, score_breakdown (JSONB), selection_rank

### AI Integration Strategy
From comprehensive analysis and demo patterns:
- **Model Selection Strategy**: GPT-4.1 for initial analysis, Gemini 2.5 Flash for quick responses, Gemini 2.5 Pro for deep thinking/strategy
- **Vercel AI SDK Integration**: Use streaming responses with proper error handling and timeout management
- **Context Assembly**: Include previous messages, current artifacts, selected frameworks, and phase-specific prompts
- **Performance Tracking**: Monitor tokens used, response time, costs per model for optimization

### Framework Selection Algorithm
Adapted from demo/action-roadmap/ patterns:
- **Problem Analysis**: Generate embeddings using OpenAI text-embedding-3-small (1536 dimensions)
- **Semantic Search**: Use existing pgvector infrastructure against knowledge_content table
- **Scoring Algorithm**: Direct relevance + applicability + foundational value + personal relevance + complementarity
- **Curation Logic**: Ensure diversity of framework types and avoid redundancy
- **Transparency**: Store detailed score breakdowns for user understanding

### File Locations
Based on unified project structure [Source: architecture/unified-project-structure.md]:
- **Core Services**: `packages/core/src/services/` (SessionManager, FrameworkSelector, AIRouter)
- **Orchestration**: `packages/core/src/orchestration/` (PhoenixOrchestrator, PhaseManager)
- **Phase Handlers**: `packages/core/src/phases/` (individual phase handler classes)
- **Type Definitions**: `packages/core/src/types/` (comprehensive TypeScript interfaces)
- **Database Migration**: `supabase/migrations/` (session management schema)
- **API Endpoint**: `apps/web/app/api/sprint/` (Next.js App Router)

### Testing Requirements
From architecture [Source: architecture/tech-stack.md]:
- **Unit Testing**: Vitest v3.4.2 for service classes and utility functions
- **Integration Testing**: Test database operations and AI model integration
- **E2E Testing**: Playwright v1.55 for complete user flows
- **Performance Testing**: Benchmark framework selection and phase transition speeds
- **Test Location**: Co-locate test files with components using `.test.ts` naming

### Technical Constraints & Performance
From tech stack and analysis:
- **Node.js v24**: Latest stable runtime for optimal performance
- **Database**: PostgreSQL with pgvector extension via Supabase
- **Vector Search**: HNSW indexing for sub-second semantic search performance
- **Streaming**: Real-time responses via Vercel AI SDK with proper timeout management
- **Caching**: Implement session state caching for performance optimization
- **Error Recovery**: Comprehensive error handling with user-friendly messages and retry logic

### Integration Points
- **Knowledge Management**: Leverage existing knowledge_content table with embeddings
- **User Management**: Integrate with existing users and user_subscriptions tables
- **Authentication**: Use Supabase Auth with proper RLS policies
- **Vector Search**: Use existing match_knowledge_content_by_subcategory() function
- **Frontend Integration**: Provide clean API for future Story 2.1 Sprint View implementation

### Architecture Patterns from Demo
Adopted from demo/action-roadmap/ analysis:
- **Orchestration Pattern**: Phase-by-phase execution with comprehensive error handling
- **Performance Tracking**: Detailed timing metrics for each operation phase
- **AI Provider Service**: Purpose-based model selection with fallback strategies
- **Timeout Management**: Configurable timeouts with graceful degradation
- **Service Layer**: Clean separation of concerns with well-defined interfaces

## Testing

### Testing Standards
From architecture [Source: architecture/tech-stack.md]:
- **Test Runner**: Vitest v3.4.2 for unit and integration tests
- **E2E Framework**: Playwright v1.55 for end-to-end testing
- **Test Files**: Co-locate test files with services using `.test.ts` naming convention
- **Coverage**: Aim for >80% coverage of core business logic
- **Integration Tests**: Test database operations, AI model calls, and service interactions
- **Performance Tests**: Benchmark framework selection, phase transitions, and overall sprint flow

### Key Test Scenarios
- Session creation and management with branching
- Message history with parent-child relationships
- Phase validation and transition logic
- Framework selection algorithm accuracy and performance
- AI model routing and context assembly
- Error handling and recovery scenarios
- Performance benchmarks for semantic search operations

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-25 | 1.0 | Initial story creation for Phoenix Core engine | Scrum Master |

## Dev Agent Record

### Agent Model Used
Opus 4.1 (claude-opus-4-1-20250805)

### Debug Log References
- Database schema migration completed: supabase/migrations/20250825_phoenix_core_session_management.sql
- TypeScript interfaces defined: packages/core/src/types/index.ts

### Completion Notes List
- Tasks 1, 2 were already complete from prior work
- Task 3: SessionManager implemented with full branching support
- Task 6: PhaseManager state machine with validation and rollback
- Task 8: All phase handlers implemented with mock framework selection
- Task 10: Comprehensive error handling and performance tracking
- Framework selection handlers use mock data pending knowledge content

### File List
**Created:**
- packages/core/src/services/session-manager.ts
- packages/core/src/orchestration/phase-manager.ts
- packages/core/src/utils/errors.ts
- packages/core/src/utils/performance-tracker.ts
- packages/core/src/phases/base-handler.ts
- packages/core/src/phases/problem-intake-handler.ts
- packages/core/src/phases/diagnostic-interview-handler.ts
- packages/core/src/phases/type-classification-handler.ts
- packages/core/src/phases/framework-selection-handler.ts
- packages/core/src/phases/framework-application-handler.ts
- packages/core/src/phases/commitment-memo-handler.ts
- packages/core/src/phases/index.ts

**Previously Created:**
- packages/core/src/types/index.ts
- supabase/migrations/20250825_phoenix_core_session_management.sql

## QA Results
*Results from QA Agent review will be populated here*